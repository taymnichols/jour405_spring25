---
title: "data_viz_analysis.rmd"
author: "Taylor Nichols"
date: "2025-05-08"
output: html_document
---
title: "final_project.rmd"
author: "Taylor Nichols"
date: "2025-04-24"
output: html_document
---

Evictions data comes from the DC Office of the Tenant Advocate. The violations data came from the DC Dept of Buildings Violations and Abatement Tool. <https://dataviz1.dc.gov/t/OCTO/views/DOBPublicDashboard/ViolationsAbatementLVT?%3AshowAppBanner=false&%3Adisplay_count=n&%3AshowVizHome=n&%3Aorigin=viz_share_link&%3Aembed=yes&%3Atoolbar=no>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)
```

```{r load libraries}
library(tidyverse)
library(tidycensus)
library(sf)
library(viridis)  # For better color palettes
#install.packages("patchwork")
library(patchwork) # For combining multiple plots
library(janitor)
library(readODS)
library(tidygeocoder)
library(tigris)
library(lubridate)
library(plotly)
```

## This section is cleaning data and getting it ready to analyze

```{r read in data}
evictions <- eviction_data <- read_csv("https://raw.githubusercontent.com/taymnichols/eviction_notice_bot_taymnichols/refs/heads/main/eviction_data_ward.csv")
df_violations <- read_delim("detailed_landlord_violations.csv", 
                           delim = "\t",  # Try tab as delimiter
                           locale = locale(encoding = "UTF-16LE"),
                           show_col_types = FALSE) |> clean_names() |>
                            mutate(created_date = case_when(str_detect(created_date, "^\\d{1,2}/\\d{1,2}/\\d{4}$") ~ mdy(created_date)))

homeowners_one <- read_ods("ods_one.ods")
homeowners_two <- read_ods("ods_2.ods")
homeowners_three <- read_ods("ods_3.ods")
homeowners_four <- read_ods("ods_4.ods")
census <- read_csv("census_data.csv")
```

```{r}
#filter our data to match
df_violations_filtered <- df_violations |>
  filter(created_date >= as.Date("2023-11-29"))

eviction_data <- evictions |>
filter(eviction_date <= as.Date("2025-03-18"))
```

```{r}
dc_homeowners <- bind_rows(homeowners_one, homeowners_two, homeowners_three, homeowners_four)
```


```{r}
violations_zip <- df_violations_filtered |>
select(violation_address) |>
  distinct() |>
  mutate(full_address = paste(violation_address, "Washington, DC")) |>
  geocode(
    address = full_address,
    method = "geocodio",
    full_results = TRUE  # Add this parameter to get all available data
  )
```

Let's add Ward data to match our evictions data.
```{r}
# Step 1: Convert violations_zip dataframe to an sf (spatial) object
points_sf <- violations_zip |>
  st_as_sf(coords = c("long", "lat"), crs = 4326)  # 4326 is the standard WGS84 coordinate system

# Step 2: Load DC ward boundaries from Open Data DC
dc_wards <- st_read("https://opendata.arcgis.com/datasets/fcfbf29074e549d8aff9b9c708179291_1.geojson") |>
  st_transform(4326)  # Ensure the ward data uses same coordinate system as our points

# Step 3: Perform spatial join to determine which ANC district each point falls within
violations_with_anc <- points_sf |>
  st_join(dc_wards |> select(ANC_ID))  # Join points with ANC polygons 

# Step 4: Extract coordinates and process the ANC ID
violations_wards <- violations_with_anc |>
  # Extract coordinates explicitly from the geometry
  mutate(
    long = st_coordinates(geometry)[,1],  # X coordinate (longitude)
    lat = st_coordinates(geometry)[,2]    # Y coordinate (latitude)
  ) |>
  st_drop_geometry() |>  # Remove the geometry column to return to standard dataframe
  mutate(
    # Extract just the number from ANC_ID (remove letters A-Z)
    clean_anc = str_replace(ANC_ID, "[A-Z]", ""),
    # Create formatted ward label ("Ward 1", "Ward 2", etc.)
    ward = paste0("Ward ", clean_anc)
  )
```

```{r}
violations_wards <- violations_wards |>
  select(violation_address, address_components.postdirectional, address_components.zip, lat, long, ward, ANC_ID) |>
  rename(quadrant = address_components.postdirectional, zipcode = address_components.zip)
```

```{r}
df_violations_filtered <- df_violations_filtered |>
  left_join(violations_wards, by = c("violation_address"))
```


```{r}
eviction_data_clean <- eviction_data |>
  select(case_number, defendant_address, quad, zipcode, eviction_date, full_address, lat, lng, ward, year, month_name)
```

```{r}
#I used Claude to help me write all this cleaning code
eviction_data_clean <- eviction_data_clean |>
  mutate(
    # First, separate the unit information from the base address
    base_address = case_when(
      # Extract everything before UNIT, APT, etc.
      str_detect(defendant_address, "(?i)\\s+(UNIT|APT|APARTMENT|SUITE|STE)\\s+[A-Z0-9-]+") ~
        str_trim(str_replace(defendant_address, 
                           "(?i)\\s+(UNIT|APT|APARTMENT|SUITE|STE)\\s+[A-Z0-9-]+.*$", "")),
      
      # If no UNIT/APT keyword, extract everything before a comma or #
      str_detect(defendant_address, "[,#]") ~
        str_trim(str_replace(str_extract(defendant_address, "^[^,#]+"), "\\s+$", "")),
      
      # Default: use the whole address if no unit information is found
      TRUE ~ defendant_address
    ),
    
    # Extract unit information
    unit_info = case_when(
      # Match "UNIT 123" format (works for UNIT 202, UNIT 409, UNIT 101, etc.)
      str_detect(defendant_address, "(?i)\\s+UNIT\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)\\s+UNIT\\s+\\d+")),
      
      # Match "APT 123" format
      str_detect(defendant_address, "(?i)\\s+APT(ARTMENT)?\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)\\s+APT(ARTMENT)?\\s+\\d+")),
      
      # Match "STE 123" format
      str_detect(defendant_address, "(?i)\\s+S(UI)?TE\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)\\s+S(UI)?TE\\s+\\d+")),
      
      # Match "#123" format
      str_detect(defendant_address, "#\\s*[A-Z0-9-]+") ~
        str_trim(str_extract(defendant_address, "#\\s*[A-Z0-9-]+")),
      
      # Match comma followed by unit information
      str_detect(defendant_address, ",\\s*(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+\\d+")),
      
      # Default: NA if no unit information is found
      TRUE ~ NA_character_
    ),
    
    # Extract just the unit number (without the UNIT/APT prefix)
    clean_unit = case_when(
      !is.na(unit_info) & str_detect(unit_info, "(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+\\d+") ~
        str_trim(str_replace(unit_info, "(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+", "")),
      
      !is.na(unit_info) & str_detect(unit_info, "#\\s*\\d+") ~
        str_trim(str_replace(unit_info, "#\\s*", "")),
      
      TRUE ~ NA_character_
    )
  ) |>
  # Now clean and standardize the base address
  mutate(
    clean_address = str_replace_all(base_address, "[,\\.]+", ""),
    
    # Standardize street suffixes
    clean_address = case_when(
      str_detect(clean_address, "(?i)\\s+STREET(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+STREET(\\s+|$)", " ST "),
      str_detect(clean_address, "(?i)\\s+AVENUE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+AVENUE(\\s+|$)", " AVE "),
      str_detect(clean_address, "(?i)\\s+CIRCLE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+CIRCLE(\\s+|$)", " CIR "),
      str_detect(clean_address, "(?i)\\s+BOULEVARD(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+BOULEVARD(\\s+|$)", " BLVD "),
      str_detect(clean_address, "(?i)\\s+COURT(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+COURT(\\s+|$)", " CT "),
      str_detect(clean_address, "(?i)\\s+DRIVE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+DRIVE(\\s+|$)", " DR "),
      str_detect(clean_address, "(?i)\\s+LANE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+LANE(\\s+|$)", " LN "),
      str_detect(clean_address, "(?i)\\s+ROAD(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+ROAD(\\s+|$)", " RD "),
      str_detect(clean_address, "(?i)\\s+PLACE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+PLACE(\\s+|$)", " PL "),
      str_detect(clean_address, "(?i)\\s+TERRACE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+TERRACE(\\s+|$)", " TER "),
      str_detect(clean_address, "(?i)\\s+HIGHWAY(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+HIGHWAY(\\s+|$)", " HWY "),
      str_detect(clean_address, "(?i)\\s+PARKWAY(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+PARKWAY(\\s+|$)", " PKWY "),
      str_detect(clean_address, "(?i)\\s+WAY(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+WAY(\\s+|$)", " WY "),
        
      # Default: keep the address as is
      TRUE ~ clean_address
    ),
    
    # Clean up any extra spaces
    clean_address = str_trim(str_replace_all(clean_address, "\\s+", " "))
  )

eviction_data_clean <- eviction_data_clean |>
  mutate(
    # Extract the street suffix pattern
    suffix_pattern = "(?i)\\s+(ST|AVE|BLVD|CIR|CT|DR|LN|RD|PL|TER|HWY|PKWY|WY)\\b",
    
    # Check if there's any remaining text after the street suffix
    has_extra_text = str_detect(clean_address, paste0(suffix_pattern, "\\s+.+")),
    
    # For addresses with extra text after suffix, update columns
    temp_address = ifelse(has_extra_text,
                         str_extract(clean_address, paste0("^.*?", suffix_pattern)),
                         clean_address),
    
    temp_unit_info = ifelse(has_extra_text,
                           str_trim(str_replace(clean_address, paste0("^.*?", suffix_pattern, "\\s+"), "")),
                           NA_character_),
    
    # Update clean_address with just the part up to the suffix
    clean_address = ifelse(has_extra_text, str_trim(temp_address), clean_address),
    
    # Update unit_info with the extra text if unit_info was previously NA
    unit_info = case_when(
      has_extra_text & is.na(unit_info) ~ temp_unit_info,
      has_extra_text & !is.na(unit_info) ~ paste(unit_info, temp_unit_info, sep = " "),
      TRUE ~ unit_info
    ),
    
    # Update clean_unit to extract numbers from the new unit_info
    clean_unit = case_when(
      # Keep existing clean_unit if already set
      !is.na(clean_unit) ~ clean_unit,
      
      # Extract numbers/alphanumeric from remaining text
      !is.na(unit_info) & str_detect(unit_info, "[0-9A-Z]+") ~
        str_trim(str_extract(unit_info, "[0-9A-Z]+")),
      
      # Extract content from patterns like (D#202)
      !is.na(unit_info) & str_detect(unit_info, "\\([^)]*#([0-9A-Z]+)\\)") ~
        str_trim(str_extract(unit_info, "(?<=\\#)[0-9A-Z]+")),
      
      # Extract T1, D2, etc. type patterns
      !is.na(unit_info) & str_detect(unit_info, "[A-Z][0-9]+") ~
        str_trim(str_extract(unit_info, "[A-Z][0-9]+")),
      
      TRUE ~ NA_character_
    )
  ) |>
  # Clean up the temporary columns
  select(-suffix_pattern, -has_extra_text, -temp_address, -temp_unit_info) |>
  filter(!str_detect(full_address, "\\bnan\\b")) |>
    filter(!str_detect(full_address, "VACANT LOT"))
```

The evictions data is still pretty messy. Units will need more cleaning, but at least we can play around with base address now.

```{r}
df_violations_clean <- df_violations_filtered |>
  select(s_no, owner, violation_address, unit, zipcode, ward, created_date, location, violation, )
```

Let's make a df that shows us how many violations have happened at each street address and how many units there are.

```{r}
# Count total violations and unique units per address
df_violations_summary <- df_violations_clean |>
  group_by(violation_address, zipcode) |>
  summarise(
    total_violations = n(),
    unique_violation_units = n_distinct(unit, na.rm = TRUE),
    unit_violation_list = paste(unique(na.omit(unit)), collapse = ", ")
  )
```

Now, let's join our violations to our evictions data. tabling this for now because i need to do some more data cleaning to do it.

```{r}
evictions_summary <- eviction_data_clean |>
  # First combine clean_address and quad (only where quad exists)
  mutate(full_address = ifelse(
    !is.na(quad),
    paste(clean_address, quad),
    clean_address
  )) |>
  # Then continue with your grouping and summarizing
  group_by(full_address, zipcode, ward) |>
  summarise(
    total_evictions = n(),
    unique_eviction_units = n_distinct(clean_unit, na.rm = TRUE),
    eviction_unit_list = toString(na.omit(unique(clean_unit)))
  )
evictions_summary <- evictions_summary |>
  mutate(zipcode = as.character(zipcode))

# Rename the address column in violations summary to match your naming convention
df_violations_summary <- df_violations_summary |>
  rename(full_address = violation_address)

df_violations_summary <- df_violations_summary |>
  mutate(zipcode = as.character(zipcode))
```

```{r}
write_csv(df_violations_summary, "df_violations_summary.csv")
write_csv(evictions_summary, "evictions_summary.csv")
write_csv(eviction_data_clean, "eviction_data_clean.csv")
write_csv(df_violations_clean, "df_violations_clean.csv")
```

```{r}
summary_df <- full_join(df_violations_summary, evictions_summary, by = c("full_address", "zipcode")) |>
    mutate(
    total_violations = replace_na(total_violations, 0),
    total_evictions = replace_na(total_evictions, 0))
```

```{r}
number_of_evictions <- summary_df |>
  group_by(total_evictions) |>
  summarise(number_of_buildings= n())

total_violations <- summary_df |>
  group_by(total_violations) |>
  summarise(number_of_buildings=n())
```


### Test 2. Correlation

Use aggregate counts by zip code, ward or census tract to see if there's a relationship between number of violations and number of evictions.

```{r}
evictions_zip <- evictions_summary |>
  group_by(zipcode) |>
  summarise(evictions = sum(total_evictions)) |>
  mutate(zipcode = as.character(zipcode))

violations_zip_agg <- df_violations_summary |>
  group_by(zipcode) |>
  summarise(violations = sum(total_violations))

aggregates <- full_join(evictions_zip, violations_zip_agg, by = c("zipcode"))
```

```{r}
aggregates |>
  ggplot(aes(x = violations, y = evictions)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE) +
  labs(x = "total_violations", y = "total_evictions", title = "evictions vs violations")
```

```{r}
evictions_summary <- evictions_summary |>
    mutate(zipcode = as.character(zipcode))
```

```{r}
merged_df <- evictions_summary |>
  full_join(df_violations_summary, by = c("full_address", "zipcode"))

zip_summary <- merged_df |>
  group_by(zipcode) |>
  summarize(
    evictions = sum(total_evictions, na.rm = TRUE),
    violations = sum(total_violations, na.rm = TRUE)
  )
```

```{r}
ward_summary <- merged_df |>
  group_by(ward) |>
  summarize(
    evictions = sum(total_evictions, na.rm = TRUE),
    violations = sum(total_violations, na.rm = TRUE)
  )

ward_summary_demographics <- ward_summary |>
  left_join(census, by = c("ward"))
```

```{r}
write_csv(ward_summary_demographics, "ward_summary_demographics.csv")
```

```{r}
# STEP 1: Identify DC ZIP codes
dc_zip_data <- get_acs(
  geography = "zcta",
  variables = "B01001_001", # Total population
  year = 2020
) 

# Extract just the GEOID values as a character vector
dc_zips <- dc_zip_data |>
  filter(str_detect(NAME, "ZCTA5 20")) |> # DC ZIP codes start with 20
  pull(GEOID)

# Print to verify it's a simple character vector
print(class(dc_zips))
print(head(dc_zips))

# STEP 2: Get renter households by ZIP code with geometry
dc_renter_households_zip <- get_acs(
  geography = "zcta",
  variables = "B25003_003", # Renter-occupied households
  year = 2020,
  geometry = TRUE
) 

# Filter to DC ZIPs and add zipcode column
dc_renter_households_zip <- dc_renter_households_zip |>
  filter(GEOID %in% dc_zips) |>
  # Use mutate with sf object
  mutate(zipcode = str_replace(NAME, "ZCTA5 ", ""))

# STEP 3: Get demographic variables for the same ZIPs
# Define variables to fetch
census_variables <- c(
  # Housing
  total_households = "B25003_001",     
  renter_households = "B25003_003",    
  
  # Income and poverty
  median_income = "B19013_001",        
  poverty = "B17001_002",              
  total_poverty_universe = "B17001_001",
  
  # Race and ethnicity
  total_pop = "B01001_001",            
  white_pop = "B02001_002",            
  black_pop = "B02001_003",            
  asian_pop = "B02001_005",            
  hispanic_pop = "B03002_012"          
)

# Fetch demographic data without geometry
dc_demo_data <- get_acs(
  geography = "zcta",
  variables = census_variables,
  year = 2020,
  geometry = FALSE  # No geometry to keep things simpler
) |>
  filter(GEOID %in% dc_zips)

# Reshape the data to wide format
dc_demo_wide <- dc_demo_data |>
  # First create a unique identifier with GEOID and variable
  mutate(id = paste(GEOID, variable, sep = "_")) |>
  # Then reshape to wide format
  select(GEOID, variable, estimate) |>
  pivot_wider(
    id_cols = GEOID,
    names_from = variable,
    values_from = estimate
  )

# Now check the structure
str(dc_demo_wide)

# Calculate derived percentages
dc_demo_wide <- dc_demo_wide |>
  mutate(
    poverty_rate = (poverty / total_poverty_universe) * 100,
    white_pct = (white_pop / total_pop) * 100,
    black_pct = (black_pop / total_pop) * 100,
    asian_pct = (asian_pop / total_pop) * 100,
    hispanic_pct = (hispanic_pop / total_pop) * 100,
    renter_pct = (renter_households / total_households) * 100
  )

# STEP 4: Join the demographic data with the spatial data
# Convert GEOID to character in both dataframes to ensure proper joining
dc_renter_households_zip$GEOID <- as.character(dc_renter_households_zip$GEOID)
dc_demo_wide$GEOID <- as.character(dc_demo_wide$GEOID)

# Join the data (this preserves the sf class)
dc_full_data <- dc_renter_households_zip |>
  left_join(dc_demo_wide, by = "GEOID")

# STEP 6: First join with eviction data
dc_full_data <- dc_full_data |>
  left_join(evictions_zip, by = "zipcode") |>
  # Calculate eviction rate
  mutate(
    eviction_rate = (evictions / renter_households) * 100
  ) |>
  filter(!is.na(eviction_rate))

# STEP 7: Second join with violations data - FIXED VERSION
dc_full_data <- dc_full_data |>
  left_join(violations_zip_agg, by = "zipcode") |>
  # Calculate violation rate - error was here
  # You had the closing parenthesis in the wrong place
  mutate(
    violation_rate = (violations / renter_households) * 100
  )
```

```{r}
write_csv(dc_full_data, "dc_full_data.csv")
```

```{r}
#install.packages("plotly")
p <- ggplot(dc_full_data, aes(x = poverty_rate, y = violation_rate, 
                            text = paste("ZIP:", zipcode, 
                                        "\nPoverty Rate:", round(poverty_rate, 1),
                                        "\nViolation Rate:", round(violation_rate, 1),
                                        "\nEviction Rate:", round(eviction_rate, 1),
                                        "\nTotal Violations:", violations))) +
  geom_point(aes(size = renter_households, color = eviction_rate), alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linetype = "dashed") +
  scale_color_viridis_c(option = "magma")

# Convert to interactive plot
ggplotly(p, tooltip = "text")
```

```{r}
evictions_weekly <- eviction_data_clean |>
  mutate(week = floor_date(eviction_date, unit = "week")) |>
           group_by(week) |>
           summarise(evictions=n())

evictions_weekly_ward <- eviction_data_clean |>
  mutate(week = floor_date(eviction_date, unit = "week")) |>
           group_by(week, ward) |>
           summarise(evictions=n())

violations_weekly <- df_violations_clean |>
   mutate(week = floor_date(created_date, unit = "week")) |>
           group_by(week) |>
           summarise(violations=n())

violations_weekly_ward <-df_violations_clean |>
   mutate(week = floor_date(created_date, unit = "week")) |>
           group_by(week, ward) |>
           summarise(violations=n())

weekly_summary <- full_join(evictions_weekly, violations_weekly, by = c("week"))
weekly_ward_summary <- full_join(evictions_weekly_ward, violations_weekly_ward, by = c("week", "ward"))
```

```{r}
weekly_ward_summary <- weekly_ward_summary %>%
  mutate(
    evictions = replace_na(evictions, 0),
    violations = replace_na(violations, 0))

weekly_summary <- weekly_summary %>%
  mutate(
    evictions = replace_na(evictions, 0),
    violations = replace_na(violations, 0))
```

```{r}
weekly_ward_summary <- weekly_ward_summary %>%
  mutate(
    # Ratio of violations to evictions (with safeguard against division by zero)
    ratio = ifelse(evictions > 0, violations / evictions, NA),
    # Simple difference
    difference = violations - evictions
  )

weekly_summary <- weekly_summary %>%
  mutate(
    # Ratio of violations to evictions (with safeguard against division by zero)
    ratio = ifelse(evictions > 0, violations / evictions, NA),
    # Simple difference
    difference = violations - evictions
  )
```

```{r}
weekly_summary_long <- weekly_summary %>%
  pivot_longer(
    cols = c(evictions, violations),
    names_to = "type",
    values_to = "count"
  ) %>%
  # Clean up the type names for better labeling
  mutate(type = case_when(
    type == "evictions" ~ "Evictions",
    type == "violations" ~ "Violations",
    TRUE ~ type
  ))

# Create the bar chart with trend lines
ggplot(weekly_summary_long, aes(x = week, y = count, fill = type)) +
  # Grouped bars
  geom_col(position = "dodge", alpha = 0.8, width = 5) +  # Adjust width as needed for your date range
  # Add trend lines
  geom_smooth(aes(color = type), method = "loess", se = FALSE, linewidth = 1) +
  # Customize colors
  scale_fill_manual(values = c("Evictions" = "#E41A1C", "Violations" = "#377EB8")) +
  scale_color_manual(values = c("Evictions" = "#E41A1C", "Violations" = "#377EB8")) +
  # Format x-axis for dates
  scale_x_date(date_breaks = "2 weeks", date_labels = "%b %d") +
  # Add labels and title
  labs(
    title = "Weekly Evictions and Violations in DC",
    subtitle = "With trend lines showing overall patterns",
    x = "Week",
    y = "Count",
    fill = "Type",
    color = "Trend"
  ) +
  # Improve appearance
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold", size = 14),
    panel.grid.minor = element_blank(),
    legend.title = element_blank()
  )
```
```{r}
ggplot(weekly_summary, aes(x = week, y = evictions)) +
  # Bars for evictions
  geom_col(fill = "#E41A1C", alpha = 0.8, width = 5) +  # Adjust width for your date range
  # Add trend line
  geom_smooth(color = "#8B0000", method = "loess", se = FALSE, linewidth = 1) +
  # Format x-axis for dates
  scale_x_date(date_breaks = "2 weeks", date_labels = "%b %d") +
  # Add labels and title
  labs(
    title = "Weekly Evictions in DC",
    subtitle = "With trend line showing overall pattern",
    x = "Week",
    y = "Number of Evictions"
  ) +
  # Improve appearance
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold", size = 14),
    panel.grid.minor = element_blank()
  )
```
```{r}
# Calculate eviction rate per 1,000 residents
ward_summary_demographics <- ward_summary_demographics %>%
  mutate(eviction_rate = (evictions / total_population) * 1000)

ggplot(ward_summary_demographics, aes(x = reorder(ward, eviction_rate), y = eviction_rate)) +
  geom_col(aes(fill = median_income), alpha = 0.8, width = 0.7) +
  scale_fill_viridis_c(option = "magma", 
                      name = "Median Income",
                      labels = scales::dollar_format()) +
  # Add exact values at the top of each bar
  geom_text(aes(label = sprintf("%.1f", eviction_rate)), 
            vjust = -0.5, size = 3.5) +
  # Improve labels and titles
  labs(title = "Eviction Rate by Ward in DC",
       subtitle = "Color indicates median household income",
       x = "Ward", 
       y = "Evictions per 1,000 residents") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.x = element_text(size = 12),
    axis.title = element_text(size = 11),
    legend.position = "right",
    panel.grid.major.x = element_blank()
  )
```



```{r}
demographic_factors <- ward_summary_demographics %>%
  select(ward, eviction_rate, black_percentage, white_percentage, 
         asian_percentage, hispanic_percentage) %>%
  pivot_longer(cols = c(black_percentage, white_percentage, 
                        asian_percentage, hispanic_percentage),
               names_to = "demographic_group", 
               values_to = "percentage") %>%
  mutate(demographic_group = case_when(
    demographic_group == "black_percentage" ~ "Black",
    demographic_group == "white_percentage" ~ "White",
    demographic_group == "asian_percentage" ~ "Asian",
    demographic_group == "hispanic_percentage" ~ "Hispanic",
    TRUE ~ demographic_group
  ))

# Create a visualization with demographic breakdown and eviction rates
ggplot(demographic_factors, aes(x = ward, y = percentage, fill = demographic_group)) +
  geom_bar(stat = "identity", position = "stack") +
  # Add a line for eviction rate
  geom_line(aes(y = eviction_rate, group = 1), color = "black", size = 1.2) +
  geom_point(aes(y = eviction_rate), color = "black", size = 3) +
  # Add labels for eviction rate
  geom_text(aes(y = eviction_rate, label = sprintf("%.1f", eviction_rate)), 
            vjust = -0.8, color = "black", size = 3.2) +
  # Create a secondary axis for eviction rate
  scale_y_continuous(
    name = "Population Percentage",
    sec.axis = sec_axis(~., name = "Evictions per 1,000 residents")
  ) +
  scale_fill_brewer(palette = "Set2", name = "Demographic Group") +
  labs(title = "Racial Demographics and Eviction Rates by Ward",
       subtitle = "Bars show demographic breakdown, line shows eviction rate",
       x = "Ward") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.x = element_text(size = 12),
    axis.title = element_text(size = 11),
    legend.position = "bottom"
  )
```

```{r}
# Create a scatterplot showing relationship between income and eviction rates
ggplot(ward_summary_demographics, aes(x = median_income, y = eviction_rate)) +
  # Add points with size representing population and color representing evictions
  geom_point(aes(size = total_population, color = evictions), alpha = 0.8) +
  # Add ward labels
  geom_text(aes(label = ward), nudge_y = 0.3, size = 4) +
  # Add trend line
  geom_smooth(method = "lm", se = TRUE, color = "darkgray", linetype = "dashed") +
  # Format scales
  scale_x_continuous(labels = scales::dollar_format()) +
  scale_color_viridis_c(option = "plasma", name = "Total Evictions") +
  scale_size_continuous(name = "Ward Population", 
                      labels = scales::comma_format()) +
  # Improve labels and titles
  labs(title = "Income vs. Eviction Rates by Ward",
       subtitle = "Point size represents ward population, color shows total evictions",
       x = "Median Household Income", 
       y = "Evictions per 1,000 residents") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 10),
    legend.position = "right"
  )
```
```{r}

# Check if geometry is already an sf object, if not convert it
if (!inherits(dc_full_data, "sf")) {
  dc_full_data <- st_as_sf(dc_full_data)
}

# Create a choropleth map of eviction rates
eviction_map <- ggplot() +
  geom_sf(data = dc_full_data, 
          aes(fill = eviction_rate, 
              text = paste("Zipcode:", zipcode,
                          "<br>Eviction Rate:", round(eviction_rate, 2),
                          "<br>Evictions:", evictions,
                          "<br>Population:", total_pop,
                          "<br>Median Income:", scales::dollar(median_income),
                          "<br>Black %:", round(black_pct, 1),
                          "<br>White %:", round(white_pct, 1),
                          "<br>Renter %:", round(renter_pct, 1))),
          color = "white", size = 0.3) +
  scale_fill_viridis_c(option = "magma", 
                     name = "Evictions per\n1,000 residents",
                     labels = scales::number_format(accuracy = 0.1)) +
  labs(title = "Eviction Rates by Zipcode in DC",
       subtitle = "Darker colors indicate higher eviction rates") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    legend.position = "right"
  )

# Convert to interactive plotly
eviction_plotly <- ggplotly(eviction_map, tooltip = "text")

# Display the interactive map
eviction_plotly
```
```{r}
# Create side-by-side maps for eviction rate and renter percentage
library(patchwork) # For combining plots

# Eviction rate map
eviction_map <- ggplot() +
  geom_sf(data = dc_full_data, 
          aes(fill = eviction_rate),
          color = "white", size = 0.3) +
  scale_fill_viridis_c(option = "magma", 
                     name = "Evictions per\n1,000 residents") +
  labs(title = "Eviction Rates") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Renter percentage map
renter_map <- ggplot() +
  geom_sf(data = dc_full_data, 
          aes(fill = renter_pct),
          color = "white", size = 0.3) +
  scale_fill_viridis_c(option = "viridis", 
                     name = "Renter %") +
  labs(title = "Renter Percentage") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Black population percentage map
black_map <- ggplot() +
  geom_sf(data = dc_full_data, 
          aes(fill = black_pct),
          color = "white", size = 0.3) +
  scale_fill_viridis_c(option = "cividis", 
                     name = "Black %") +
  labs(title = "Black Population %") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Median income map
income_map <- ggplot() +
  geom_sf(data = dc_full_data, 
          aes(fill = median_income),
          color = "white", size = 0.3) +
  scale_fill_viridis_c(option = "plasma", 
                     name = "Median Income",
                     labels = scales::dollar_format()) +
  labs(title = "Median Income") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Combine the maps into a 2x2 grid
combined_maps <- (eviction_map + renter_map) / (black_map + income_map) +
  plot_annotation(
    title = "Relationships Between Eviction Rates and Demographic Factors in DC",
    theme = theme(plot.title = element_text(size = 16, face = "bold"))
  )

# Display the combined map
combined_maps
```
```{r}
# Load necessary libraries
library(broom)
library(ggplot2)
library(dplyr)

# Run multiple regression models to understand relationships beyond simple correlations
model1 <- lm(eviction_rate ~ renter_pct + black_pct, data = dc_full_data)
model2 <- lm(eviction_rate ~ renter_pct + black_pct + median_income, data = dc_full_data)
model3 <- lm(eviction_rate ~ renter_pct + black_pct + median_income + poverty_rate, data = dc_full_data)

# Summarize models
model_summary <- bind_rows(
  tidy(model1) %>% mutate(model = "Base Model"),
  tidy(model2) %>% mutate(model = "With Income"),
  tidy(model3) %>% mutate(model = "Full Model")
)

# Visualize regression coefficients to see which factors remain significant after controls
ggplot(model_summary %>% filter(term != "(Intercept)"), 
       aes(x = term, y = estimate, fill = model)) +
  geom_col(position = "dodge", alpha = 0.8) +
  geom_errorbar(aes(ymin = estimate - std.error, ymax = estimate + std.error),
                position = position_dodge(width = 0.9), width = 0.2) +
  coord_flip() +
  labs(title = "Regression Coefficients for Eviction Rate Predictors",
       subtitle = "Showing which factors remain significant after controlling for others",
       y = "Coefficient Estimate") +
  theme_minimal()

# Create a residual map to show areas with higher/lower eviction rates than predicted
dc_full_data$residuals <- residuals(model3)
dc_full_data$predicted <- predict(model3)

# Map of residuals
ggplot() +
  geom_sf(data = dc_full_data, 
          aes(fill = residuals, 
              text = paste("Zipcode:", zipcode,
                           "<br>Actual Rate:", round(eviction_rate, 2),
                           "<br>Predicted Rate:", round(predicted, 2),
                           "<br>Residual:", round(residuals, 2))),
          color = "white", size = 0.3) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0,
                      name = "Residual\n(Actual - Predicted)") +
  labs(title = "Where Eviction Rates Differ from Demographic Predictions",
       subtitle = "Red areas have higher eviction rates than demographics would predict") +
  theme_minimal()
```
```{r}
# Calculate correlation coefficient
correlation <- cor(dc_full_data$violations, dc_full_data$evictions, 
                  use = "pairwise.complete.obs")

# Create scatter plot
ggplot(dc_full_data, aes(x = violations, y = evictions)) +
  geom_point(aes(size = total_pop, color = black_pct), alpha = 0.7) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  geom_text(aes(label = zipcode), vjust = -0.8, size = 3, check_overlap = TRUE) +
  annotate("text", x = max(dc_full_data$violations, na.rm = TRUE) * 0.8, 
           y = max(dc_full_data$evictions, na.rm = TRUE) * 0.2,
           label = paste("Correlation:", round(correlation, 2)),
           size = 5, fontface = "bold") +
  scale_color_viridis_c(name = "Black Population %") +
  scale_size_continuous(name = "Total Population") +
  labs(title = "Relationship Between Housing Violations and Evictions by Zipcode",
       subtitle = "Point size represents population, color shows Black population percentage",
       x = "Number of Housing Violations", 
       y = "Number of Evictions") +
  theme_minimal()

# Create normalized version (per 1000 residents)
ggplot(dc_full_data, aes(x = violation_rate, y = eviction_rate)) +
  geom_point(aes(size = total_pop, color = median_income), alpha = 0.7) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  geom_text(aes(label = zipcode), vjust = -0.8, size = 3, check_overlap = TRUE) +
  scale_color_viridis_c(name = "Median Income", 
                      labels = scales::dollar_format()) +
  labs(title = "Relationship Between Violation and Eviction Rates",
       subtitle = "Controlling for population size",
       x = "Housing Violations per 1,000 Residents", 
       y = "Evictions per 1,000 Residents") +
  theme_minimal()
```

```{r}
# Define high as top quartile (75th percentile)
dc_full_data <- dc_full_data %>%
  mutate(
    eviction_threshold = quantile(eviction_rate, 0.75, na.rm = TRUE),
    violation_threshold = quantile(violation_rate, 0.75, na.rm = TRUE),
    relationship_type = case_when(
      eviction_rate > eviction_threshold & 
        violation_rate > violation_threshold ~ "High Both",
      eviction_rate > eviction_threshold & 
        violation_rate <= violation_threshold ~ "High Eviction, Low Violation",
      eviction_rate <= eviction_threshold & 
        violation_rate > violation_threshold ~ "Low Eviction, High Violation",
      TRUE ~ "Low Both"
    )
  )

# Map the relationship types
ggplot() +
  geom_sf(data = dc_full_data, 
          aes(fill = relationship_type),
          color = "white", size = 0.2) +
  scale_fill_brewer(palette = "Set1", name = "Relationship Type") +
  labs(title = "Patterns of Eviction and Violation Rates Across DC",
       subtitle = "Identifying areas with different eviction-violation relationships") +
  theme_minimal()


```
```{r}
write_csv(dc_full_data, "dc_full_data.csv")
```

```{r}
# Match violations and evictions by property address
property_analysis <- merged_df |>
  mutate(
    # Replace NAs with 0 for violations
    total_violations = replace_na(total_violations, 0),
    total_evictions = replace_na(total_evictions, 0),
    # Create binary indicators
    has_violations = total_violations > 0,
    has_evictions = total_evictions > 0
  ) |>
  # Rename for consistency with analysis examples
  rename(
    violation_count = total_violations,
    eviction_count = total_evictions
  )

# Analyze the contingency table
contingency_table <- with(property_analysis, table(has_violations, has_evictions))
print(contingency_table)

# Chi-square test
chisq_test <- chisq.test(contingency_table)
print(chisq_test)

# Calculate relative risk
relative_risk <- (contingency_table[2,2] / sum(contingency_table[2,])) / 
                 (contingency_table[1,2] / sum(contingency_table[1,]))
print(paste("Properties with violations are", round(relative_risk, 2), 
            "times more likely to have evictions"))

# Visualize property-level relationship
ggplot(property_analysis, aes(x = violation_count, y = eviction_count)) +
  geom_jitter(alpha = 0.5, width = 0.2, height = 0.2) +
  geom_smooth(method = "loess", color = "red") +
  scale_x_log10(labels = scales::comma_format()) +
  scale_y_log10(labels = scales::comma_format()) +
  labs(title = "Relationship Between Violations and Evictions at Property Level",
       subtitle = "Each point represents a property address",
       x = "Number of Violations (log scale)", 
       y = "Number of Evictions (log scale)") +
  theme_minimal()
```

```{r}
# Focus on buildings with both violations and evictions
hotspot_buildings <- property_analysis %>%
  filter(has_violations & has_evictions) %>%
  # Calculate total counts to find the most problematic buildings
  arrange(desc(violation_count + eviction_count))

# Display top hotspots
top_hotspots <- hotspot_buildings %>%
  slice_head(n = 20) %>%
  mutate(
    total_issues = violation_count + eviction_count,
    # Create an anonymized building ID for privacy if needed
    building_id = paste0("Building ", row_number())
  ) %>%
  select(building_id, full_address, violation_count, eviction_count, total_issues) %>%
  arrange(desc(total_issues))


# Spatial clustering of hotspots by neighborhood or zipcode
hotspot_by_area <- hotspot_buildings %>%
  group_by(zipcode) %>%
  summarize(
    buildings_count = n(),
    total_violations = sum(violation_count),
    total_evictions = sum(eviction_count),
    avg_violations_per_building = mean(violation_count),
    avg_evictions_per_building = mean(eviction_count)
  ) %>%
  arrange(desc(buildings_count))

# Visualize hotspot concentrations by zipcode
ggplot(hotspot_by_area, aes(x = reorder(zipcode, buildings_count), y = buildings_count)) +
  geom_col(fill = "darkred", alpha = 0.8) +
  coord_flip() +
  labs(title = "Number of Hotspot Buildings by Zipcode",
       subtitle = "Areas with the most buildings having both violations and evictions",
       x = "Zipcode",
       y = "Number of Hotspot Buildings") +
  theme_minimal()
```

```{r}
# Focus on buildings with higher numbers of either violations or evictions
high_frequency_buildings <- property_analysis %>%
  filter(violation_count >= 3 | eviction_count >= 3)

# Analyze correlation specifically among these high-frequency buildings
high_freq_correlation <- cor(high_frequency_buildings$violation_count, 
                            high_frequency_buildings$eviction_count, 
                            use = "pairwise.complete.obs")

# Visualize relationship for high-frequency buildings
ggplot(high_frequency_buildings, aes(x = violation_count, y = eviction_count)) +
  geom_point(aes(size = violation_count + eviction_count), 
             alpha = 0.6, color = "purple") +
  geom_smooth(method = "lm", color = "black", linetype = "dashed") +
  scale_size_continuous(range = c(2, 10), name = "Total Issues") +
  annotate("text", x = max(high_frequency_buildings$violation_count) * 0.8, 
           y = max(high_frequency_buildings$eviction_count) * 0.9,
           label = paste("Correlation:", round(high_freq_correlation, 2)),
           size = 5, fontface = "bold") +
  labs(title = "Relationship Between Violations and Evictions in High-Frequency Buildings",
       subtitle = "Limited to buildings with at least 3 violations or 3 evictions",
       x = "Number of Violations", 
       y = "Number of Evictions") +
  theme_minimal()

# Create a quadrant analysis of high-frequency buildings
high_frequency_buildings <- high_frequency_buildings %>%
  mutate(
    # Create quadrants based on median values
    quadrant = case_when(
      violation_count >= median(violation_count) & 
        eviction_count >= median(eviction_count) ~ "High Violations, High Evictions",
      violation_count >= median(violation_count) & 
        eviction_count < median(eviction_count) ~ "High Violations, Low Evictions",
      violation_count < median(violation_count) & 
        eviction_count >= median(eviction_count) ~ "Low Violations, High Evictions",
      TRUE ~ "Low Violations, Low Evictions"
    )
  )

# Visualize quadrants
ggplot(high_frequency_buildings, aes(x = violation_count, y = eviction_count, color = quadrant)) +
  geom_point(alpha = 0.7, size = 3) +
  geom_vline(xintercept = median(high_frequency_buildings$violation_count), 
             linetype = "dashed", color = "gray40") +
  geom_hline(yintercept = median(high_frequency_buildings$eviction_count), 
             linetype = "dashed", color = "gray40") +
  scale_color_brewer(palette = "Set1", name = "Quadrant") +
  labs(title = "Quadrant Analysis of High-Frequency Buildings",
       subtitle = "Identifying patterns among buildings with higher violation or eviction counts",
       x = "Number of Violations", 
       y = "Number of Evictions") +
  theme_minimal()
```

```{r}
evictions_weekly_ward
```

```{r}
monthly_evictions <- eviction_data_clean |>
  # Create a month_year column from eviction_date
  mutate(
    # Format as "Month Year" (e.g., "January 2024")
    month_year = format(eviction_date, "%B %Y"),
    
    # Alternative format as "YYYY-MM" for better sorting (e.g., "2024-01")
    month_year_sort = format(eviction_date, "%Y-%m")
  ) |>
  # Group by month_name and year for the summary
  group_by(month_name, year, month_year, month_year_sort) |>
  # Count evictions
  summarise(total_evictions = n(), .groups = "drop")
```

```{r}
# Create a bar chart with a bar for each month of each year
monthly_yearly_bar_chart <- eviction_data_clean |>
  # Create month_year column in the format we need
  mutate(
    # Format as "Mon YYYY" for compact display (e.g., "Jan 2024")
    month_year = format(eviction_date, "%b %Y"),
    # Extract month number for ordering within each year
    month_num = month(eviction_date),
    # Extract year for grouping
    year = year(eviction_date)
  ) |>
  # Group by these time components
  group_by(year, month_num, month_year) |>
  # Count evictions
  summarise(total_evictions = n(), .groups = "drop") |>
  # Order by year and month for proper chronological ordering
  arrange(year, month_num) |>
  # Create a factor with levels in chronological order for plotting
  mutate(month_year = factor(month_year, levels = unique(month_year))) |>
  # Create the plot
  ggplot(aes(x = month_year, y = total_evictions, fill = factor(year))) +
  geom_bar(stat = "identity") +
  # Add count labels on top of bars
  geom_text(aes(label = total_evictions), vjust = -0.5, size = 3) +
  # Use a nice color palette for different years
  scale_fill_brewer(palette = "Set2", name = "Year") +
  # Add informative labels
  labs(
    title = "Monthly Eviction Filings by Year",
    subtitle = "Number of evictions filed in each month of each year",
    x = "Month & Year",
    y = "Number of Evictions"
  ) +
  # Apply styling
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

# Display the chart
print(monthly_yearly_bar_chart)

```

