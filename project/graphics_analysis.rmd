---
title: "data_viz_analysis.rmd"
author: "Taylor Nichols"
date: "2025-05-08"
output: html_document
---
title: "final_project.rmd"
author: "Taylor Nichols"
date: "2025-04-24"
output: html_document
---

Evictions data comes from the DC Office of the Tenant Advocate. The violations data came from the DC Dept of Buildings Violations and Abatement Tool. <https://dataviz1.dc.gov/t/OCTO/views/DOBPublicDashboard/ViolationsAbatementLVT?%3AshowAppBanner=false&%3Adisplay_count=n&%3AshowVizHome=n&%3Aorigin=viz_share_link&%3Aembed=yes&%3Atoolbar=no>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)
```

```{r load libraries}
library(tidyverse)
library(tidycensus)
library(sf)
library(viridis)  # For better color palettes
install.packages("patchwork")
library(patchwork) # For combining multiple plots
```

## This section is cleaning data and getting it ready to analyze

```{r read in data}
eviction_data <- read_csv("eviction_data_ward_geocodio.csv")
df_violations <- read_delim("detailed_landlord_violations.csv", 
                           delim = "\t",  # Try tab as delimiter
                           locale = locale(encoding = "UTF-16LE"),
                           show_col_types = FALSE) |> clean_names() |>
                            mutate(created_date = case_when(str_detect(created_date, "^\\d{1,2}/\\d{1,2}/\\d{4}$") ~ mdy(created_date)))

homeowners_one <- read_ods("ods_one.ods")
homeowners_two <- read_ods("ods_2.ods")
homeowners_three <- read_ods("ods_3.ods")
homeowners_four <- read_ods("ods_4.ods")
census <- read_csv("census_data.csv")
```

```{r}
dc_homeowners <- bind_rows(homeowners_one, homeowners_two, homeowners_three, homeowners_four)
```


```{r}
violations_zip <- df_violations |>
select(violation_address) |>
  distinct() |>
  mutate(full_address = paste(violation_address, "Washington, DC")) |>
  geocode(
    address = full_address,
    method = "geocodio",
    full_results = TRUE  # Add this parameter to get all available data
  )
```

```{r}
violations_zip <- violations_zip |>
  select(violation_address, address_components.postdirectional, address_components.zip, lat, long) |>
  rename(quadrant = address_components.postdirectional, zipcode = address_components.zip)
```

```{r}
df_violations <- df_violations |>
  left_join(violations_zip, by = c("violation_address"))
```


```{r}
eviction_data_clean <- eviction_data |>
  select(case_number, defendant_address, quad, zipcode, eviction_date, full_address, lat, lng, ward, year, month_name)
```

```{r}
#I used Claude to help me write all this cleaning code
eviction_data_clean <- eviction_data_clean %>%
  mutate(
    # First, separate the unit information from the base address
    base_address = case_when(
      # Extract everything before UNIT, APT, etc.
      str_detect(defendant_address, "(?i)\\s+(UNIT|APT|APARTMENT|SUITE|STE)\\s+[A-Z0-9-]+") ~
        str_trim(str_replace(defendant_address, 
                           "(?i)\\s+(UNIT|APT|APARTMENT|SUITE|STE)\\s+[A-Z0-9-]+.*$", "")),
      
      # If no UNIT/APT keyword, extract everything before a comma or #
      str_detect(defendant_address, "[,#]") ~
        str_trim(str_replace(str_extract(defendant_address, "^[^,#]+"), "\\s+$", "")),
      
      # Default: use the whole address if no unit information is found
      TRUE ~ defendant_address
    ),
    
    # Extract unit information
    unit_info = case_when(
      # Match "UNIT 123" format (works for UNIT 202, UNIT 409, UNIT 101, etc.)
      str_detect(defendant_address, "(?i)\\s+UNIT\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)\\s+UNIT\\s+\\d+")),
      
      # Match "APT 123" format
      str_detect(defendant_address, "(?i)\\s+APT(ARTMENT)?\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)\\s+APT(ARTMENT)?\\s+\\d+")),
      
      # Match "STE 123" format
      str_detect(defendant_address, "(?i)\\s+S(UI)?TE\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)\\s+S(UI)?TE\\s+\\d+")),
      
      # Match "#123" format
      str_detect(defendant_address, "#\\s*[A-Z0-9-]+") ~
        str_trim(str_extract(defendant_address, "#\\s*[A-Z0-9-]+")),
      
      # Match comma followed by unit information
      str_detect(defendant_address, ",\\s*(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+\\d+") ~
        str_trim(str_extract(defendant_address, "(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+\\d+")),
      
      # Default: NA if no unit information is found
      TRUE ~ NA_character_
    ),
    
    # Extract just the unit number (without the UNIT/APT prefix)
    clean_unit = case_when(
      !is.na(unit_info) & str_detect(unit_info, "(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+\\d+") ~
        str_trim(str_replace(unit_info, "(?i)(UNIT|APT|APARTMENT|SUITE|STE)\\s+", "")),
      
      !is.na(unit_info) & str_detect(unit_info, "#\\s*\\d+") ~
        str_trim(str_replace(unit_info, "#\\s*", "")),
      
      TRUE ~ NA_character_
    )
  ) %>%
  # Now clean and standardize the base address
  mutate(
    clean_address = str_replace_all(base_address, "[,\\.]+", ""),
    
    # Standardize street suffixes
    clean_address = case_when(
      str_detect(clean_address, "(?i)\\s+STREET(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+STREET(\\s+|$)", " ST "),
      str_detect(clean_address, "(?i)\\s+AVENUE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+AVENUE(\\s+|$)", " AVE "),
      str_detect(clean_address, "(?i)\\s+CIRCLE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+CIRCLE(\\s+|$)", " CIR "),
      str_detect(clean_address, "(?i)\\s+BOULEVARD(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+BOULEVARD(\\s+|$)", " BLVD "),
      str_detect(clean_address, "(?i)\\s+COURT(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+COURT(\\s+|$)", " CT "),
      str_detect(clean_address, "(?i)\\s+DRIVE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+DRIVE(\\s+|$)", " DR "),
      str_detect(clean_address, "(?i)\\s+LANE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+LANE(\\s+|$)", " LN "),
      str_detect(clean_address, "(?i)\\s+ROAD(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+ROAD(\\s+|$)", " RD "),
      str_detect(clean_address, "(?i)\\s+PLACE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+PLACE(\\s+|$)", " PL "),
      str_detect(clean_address, "(?i)\\s+TERRACE(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+TERRACE(\\s+|$)", " TER "),
      str_detect(clean_address, "(?i)\\s+HIGHWAY(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+HIGHWAY(\\s+|$)", " HWY "),
      str_detect(clean_address, "(?i)\\s+PARKWAY(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+PARKWAY(\\s+|$)", " PKWY "),
      str_detect(clean_address, "(?i)\\s+WAY(\\s+|$)") ~ 
        str_replace_all(clean_address, "(?i)\\s+WAY(\\s+|$)", " WY "),
        
      # Default: keep the address as is
      TRUE ~ clean_address
    ),
    
    # Clean up any extra spaces
    clean_address = str_trim(str_replace_all(clean_address, "\\s+", " "))
  )

eviction_data_clean <- eviction_data_clean %>%
  mutate(
    # Extract the street suffix pattern
    suffix_pattern = "(?i)\\s+(ST|AVE|BLVD|CIR|CT|DR|LN|RD|PL|TER|HWY|PKWY|WY)\\b",
    
    # Check if there's any remaining text after the street suffix
    has_extra_text = str_detect(clean_address, paste0(suffix_pattern, "\\s+.+")),
    
    # For addresses with extra text after suffix, update columns
    temp_address = ifelse(has_extra_text,
                         str_extract(clean_address, paste0("^.*?", suffix_pattern)),
                         clean_address),
    
    temp_unit_info = ifelse(has_extra_text,
                           str_trim(str_replace(clean_address, paste0("^.*?", suffix_pattern, "\\s+"), "")),
                           NA_character_),
    
    # Update clean_address with just the part up to the suffix
    clean_address = ifelse(has_extra_text, str_trim(temp_address), clean_address),
    
    # Update unit_info with the extra text if unit_info was previously NA
    unit_info = case_when(
      has_extra_text & is.na(unit_info) ~ temp_unit_info,
      has_extra_text & !is.na(unit_info) ~ paste(unit_info, temp_unit_info, sep = " "),
      TRUE ~ unit_info
    ),
    
    # Update clean_unit to extract numbers from the new unit_info
    clean_unit = case_when(
      # Keep existing clean_unit if already set
      !is.na(clean_unit) ~ clean_unit,
      
      # Extract numbers/alphanumeric from remaining text
      !is.na(unit_info) & str_detect(unit_info, "[0-9A-Z]+") ~
        str_trim(str_extract(unit_info, "[0-9A-Z]+")),
      
      # Extract content from patterns like (D#202)
      !is.na(unit_info) & str_detect(unit_info, "\\([^)]*#([0-9A-Z]+)\\)") ~
        str_trim(str_extract(unit_info, "(?<=\\#)[0-9A-Z]+")),
      
      # Extract T1, D2, etc. type patterns
      !is.na(unit_info) & str_detect(unit_info, "[A-Z][0-9]+") ~
        str_trim(str_extract(unit_info, "[A-Z][0-9]+")),
      
      TRUE ~ NA_character_
    )
  ) %>%
  # Clean up the temporary columns
  select(-suffix_pattern, -has_extra_text, -temp_address, -temp_unit_info) |>
  filter(!str_detect(full_address, "\\bnan\\b")) |>
    filter(!str_detect(full_address, "VACANT LOT"))
```

The evictions data is still pretty messy. Units will need more cleaning, but at least we can play around with base address now.

```{r}
df_violations_clean <- df_violations |>
  select(s_no, owner, violation_address, unit, zipcode, created_date, location, violation)
```

Let's make a df that shows us how many violations have happened at each street address and how many units there are.

```{r}
# Count total violations and unique units per address
df_violations_summary <- df_violations_clean |>
  group_by(violation_address, zipcode) |>
  summarise(
    total_violations = n(),
    unique_violation_units = n_distinct(unit, na.rm = TRUE),
    unit_violation_list = paste(unique(na.omit(unit)), collapse = ", ")
  )
```

Now, let's join our violations to our evictions data. tabling this for now because i need to do some more data cleaning to do it.

```{r}
evictions_summary <- eviction_data_clean |>
  # First combine clean_address and quad (only where quad exists)
  mutate(full_address = ifelse(
    !is.na(quad),
    paste(clean_address, quad),
    clean_address
  )) |>
  # Then continue with your grouping and summarizing
  group_by(full_address, zipcode, ward) |>
  summarise(
    total_evictions = n(),
    unique_eviction_units = n_distinct(clean_unit, na.rm = TRUE),
    eviction_unit_list = toString(na.omit(unique(clean_unit)))
  )
evictions_summary <- evictions_summary |>
  mutate(zipcode = as.character(zipcode))

# Rename the address column in violations summary to match your naming convention
df_violations_summary <- df_violations_summary |>
  rename(full_address = violation_address)

df_violations_summary <- df_violations_summary |>
  mutate(zipcode = as.character(zipcode))
```

```{r}
write_csv(df_violations_summary, "df_violations_summary.csv")
write_csv(evictions_summary, "evictions_summary.csv")
```

```{r}
summary_df <- full_join(df_violations_summary, evictions_summary, by = c("full_address", "zipcode")) |>
    mutate(
    total_violations = replace_na(total_violations, 0),
    total_evictions = replace_na(total_evictions, 0))
```

```{r}
number_of_evictions <- summary_df |>
  group_by(total_evictions) |>
  summarise(number_of_buildings= n())

total_violations <- summary_df |>
  group_by(total_violations) |>
  summarise(number_of_buildings=n())
```


### Test 2. Correlation

Use aggregate counts by zip code, ward or census tract to see if there's a relationship between number of violations and number of evictions.

```{r}
evictions_zip <- evictions_summary |>
  group_by(zipcode) |>
  summarise(evictions = sum(total_evictions)) |>
  mutate(zipcode = as.character(zipcode))

violations_zip_agg <- df_violations_summary |>
  group_by(zipcode) |>
  summarise(violations = sum(total_violations))

aggregates <- full_join(evictions_zip, violations_zip_agg, by = c("zipcode"))
```

```{r}
aggregates |>
  ggplot(aes(x = violations, y = evictions)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE) +
  labs(x = "total_violations", y = "total_evictions", title = "evictions vs violations")
```

```{r}
evictions_summary <- evictions_summary |>
    mutate(zipcode = as.character(zipcode))
```

```{r}
merged_df <- evictions_summary |>
  full_join(df_violations_summary, by = c("full_address", "zipcode"))

zip_summary <- merged_df %>%
  group_by(zipcode) %>%
  summarize(
    evictions = sum(total_evictions, na.rm = TRUE),
    violations = sum(total_violations, na.rm = TRUE)
  )
```

```{r}
# STEP 1: Identify DC ZIP codes
dc_zip_data <- get_acs(
  geography = "zcta",
  variables = "B01001_001", # Total population
  year = 2020
) 

# Extract just the GEOID values as a character vector
dc_zips <- dc_zip_data %>%
  filter(str_detect(NAME, "ZCTA5 20")) %>% # DC ZIP codes start with 20
  pull(GEOID)

# Print to verify it's a simple character vector
print(class(dc_zips))
print(head(dc_zips))

# STEP 2: Get renter households by ZIP code with geometry
dc_renter_households_zip <- get_acs(
  geography = "zcta",
  variables = "B25003_003", # Renter-occupied households
  year = 2020,
  geometry = TRUE
) 

# Filter to DC ZIPs and add zipcode column
dc_renter_households_zip <- dc_renter_households_zip %>%
  filter(GEOID %in% dc_zips) %>%
  # Use mutate with sf object
  mutate(zipcode = str_replace(NAME, "ZCTA5 ", ""))

# STEP 3: Get demographic variables for the same ZIPs
# Define variables to fetch
census_variables <- c(
  # Housing
  total_households = "B25003_001",     
  renter_households = "B25003_003",    
  
  # Income and poverty
  median_income = "B19013_001",        
  poverty = "B17001_002",              
  total_poverty_universe = "B17001_001",
  
  # Race and ethnicity
  total_pop = "B01001_001",            
  white_pop = "B02001_002",            
  black_pop = "B02001_003",            
  asian_pop = "B02001_005",            
  hispanic_pop = "B03002_012"          
)

# Fetch demographic data without geometry
dc_demo_data <- get_acs(
  geography = "zcta",
  variables = census_variables,
  year = 2020,
  geometry = FALSE  # No geometry to keep things simpler
) %>%
  filter(GEOID %in% dc_zips)

# Reshape the data to wide format
dc_demo_wide <- dc_demo_data %>%
  # First create a unique identifier with GEOID and variable
  mutate(id = paste(GEOID, variable, sep = "_")) %>%
  # Then reshape to wide format
  select(GEOID, variable, estimate) %>%
  pivot_wider(
    id_cols = GEOID,
    names_from = variable,
    values_from = estimate
  )

# Now check the structure
str(dc_demo_wide)

# Calculate derived percentages
dc_demo_wide <- dc_demo_wide %>%
  mutate(
    poverty_rate = (poverty / total_poverty_universe) * 100,
    white_pct = (white_pop / total_pop) * 100,
    black_pct = (black_pop / total_pop) * 100,
    asian_pct = (asian_pop / total_pop) * 100,
    hispanic_pct = (hispanic_pop / total_pop) * 100,
    renter_pct = (renter_households / total_households) * 100
  )

# STEP 4: Join the demographic data with the spatial data
# Convert GEOID to character in both dataframes to ensure proper joining
dc_renter_households_zip$GEOID <- as.character(dc_renter_households_zip$GEOID)
dc_demo_wide$GEOID <- as.character(dc_demo_wide$GEOID)

# Join the data (this preserves the sf class)
dc_full_data <- dc_renter_households_zip %>%
  left_join(dc_demo_wide, by = "GEOID")

# STEP 6: First join with eviction data
dc_full_data <- dc_full_data %>%
  left_join(evictions_zip, by = "zipcode") %>%
  # Calculate eviction rate
  mutate(
    eviction_rate = (evictions / total_households) * 100
  ) %>%
  filter(!is.na(eviction_rate))

# STEP 7: Second join with violations data - FIXED VERSION
dc_full_data <- dc_full_data %>%
  left_join(violations_zip_agg, by = "zipcode") %>%
  # Calculate violation rate - error was here
  # You had the closing parenthesis in the wrong place
  mutate(
    violation_rate = (violations / total_households) * 100
  )

# STEP 7: Create maps
# Map of eviction rates
eviction_map <- ggplot(dc_full_data) +
  geom_sf(aes(fill = eviction_rate)) +
  scale_fill_viridis_c(option = "magma", name = "Evictions per 100\nRenter Households") +
  theme_minimal() +
  labs(title = "Eviction Rates by ZIP Code in DC")

# Map of poverty rates
poverty_map <- ggplot(dc_full_data) +
  geom_sf(aes(fill = poverty_rate)) +
  scale_fill_viridis_c(option = "inferno", name = "Poverty Rate (%)") +
  theme_minimal() +
  labs(title = "Poverty Rate by ZIP Code in DC")

# Map of Black population percentage
black_pop_map <- ggplot(dc_full_data) +
  geom_sf(aes(fill = black_pct)) +
  scale_fill_viridis_c(option = "viridis", name = "Black Population (%)") +
  theme_minimal() +
  labs(title = "Black Population by ZIP Code in DC")

# Combine maps
eviction_map / poverty_map / black_pop_map

print(eviction_map)
print(poverty_map) 
print(black_pop_map)
```

```{r}
write_csv(dc_full_data, "dc_full_data.csv")
```

```{r}
install.packages("plotly")
library(plotly)

p <- ggplot(dc_full_data, aes(x = poverty_rate, y = violation_rate, 
                            text = paste("ZIP:", zipcode, 
                                        "\nPoverty Rate:", round(poverty_rate, 1),
                                        "\nViolation Rate:", round(violation_rate, 1),
                                        "\nEviction Rate:", round(eviction_rate, 1),
                                        "\nTotal Violations:", violations))) +
  geom_point(aes(size = total_households, color = eviction_rate), alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linetype = "dashed") +
  scale_color_viridis_c(option = "magma")

# Convert to interactive plot
ggplotly(p, tooltip = "text")
```

